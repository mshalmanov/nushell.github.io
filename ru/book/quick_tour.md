# Быстрый тур

[[toc]]

## Nushell Команды Вывода _Data_

Самый простой способ увидеть, что может делать Nu, — это начать с нескольких примеров, так что давайте погрузимся.

Первое, что вы заметите, когда выполните команду, такую как [`ls`](/commands/docs/ls.md), это то, что вместо блока текста вы получите структурированную таблицу.

```nu:no-line-numbers
ls
# => ╭────┬─────────────────────┬──────┬───────────┬──────────────╮
# => │  # │        name         │ type │   size    │   modified   │
# => ├────┼─────────────────────┼──────┼───────────┼──────────────┤
# => │  0 │ CITATION.cff        │ file │     812 B │ 2 months ago │
# => │  1 │ CODE_OF_CONDUCT.md  │ file │   3.4 KiB │ 9 months ago │
# => │  2 │ CONTRIBUTING.md     │ file │  11.0 KiB │ 5 months ago │
# => │  3 │ Cargo.lock          │ file │ 194.9 KiB │ 15 hours ago │
# => │  4 │ Cargo.toml          │ file │   9.2 KiB │ 15 hours ago │
# => │  5 │ Cross.toml          │ file │     666 B │ 6 months ago │
# => │  6 │ LICENSE             │ file │   1.1 KiB │ 9 months ago │
# => │  7 │ README.md           │ file │  12.0 KiB │ 15 hours ago │
# => ...
```

Эта таблица не только красиво форматирует вывод. Как и в электронной таблице, она позволяет нам работать с данными _интерактивно_.

## Действия с данными

Далее, давайте отсортируем эту таблицу по размеру каждого файла. Для этого мы возьмем вывод команды [`ls`](/commands/docs/ls.md) и передадим его в команду, которая может сортировать таблицы на основе _значений_ в столбце.

```nu:no-line-numbers
ls | sort-by size | reverse
# => ╭───┬─────────────────┬──────┬───────────┬──────────────╮
# => │ # │      name       │ type │   size    │   modified   │
# => ├───┼─────────────────┼──────┼───────────┼──────────────┤
# => │ 0 │ Cargo.lock      │ file │ 194.9 KiB │ 15 hours ago │
# => │ 1 │ toolkit.nu      │ file │  20.0 KiB │ 15 hours ago │
# => │ 2 │ README.md       │ file │  12.0 KiB │ 15 hours ago │
# => │ 3 │ CONTRIBUTING.md │ file │  11.0 KiB │ 5 months ago │
# => │ 4 │ ...             │ ...  │ ...       │ ...          │
# => │ 5 │ LICENSE         │ file │   1.1 KiB │ 9 months ago │
# => │ 6 │ CITATION.cff    │ file │     812 B │ 2 months ago │
# => │ 7 │ Cross.toml      │ file │     666 B │ 6 months ago │
# => │ 8 │ typos.toml      │ file │     513 B │ 2 months ago │
# => ╰───┴─────────────────┴──────┴───────────┴──────────────╯
```

Обратите внимание, что мы не передавали аргументы командной строки или переключатели в [`ls`](/commands/docs/ls.md). Вместо этого мы использовали встроенную команду Nushell [`sort-by`](/commands/docs/sort-by.md) для сортировки _вывода_ команды `ls`. Затем, чтобы увидеть самые большие файлы сверху, мы использовали [`reverse`](/commands/docs/reverse.md) на _выводе_ `sort-by`.

::: tip Круто!
Если вы внимательно сравните порядок сортировки, вы можете заметить, что данные не отсортированы в алфавитном порядке. Они даже не отсортированы по _числовым_ значениям. Вместо этого, поскольку столбец `size` является типом [`filesize`](./types_of_data.md#file-sizes), Nushell знает, что `1.1 KiB` (кибибайты) больше, чем `812 B` (байты).
:::

# Поиск данных с помощью команды `where`

Nu предоставляет множество команд, которые могут работать со структурированным выводом предыдущей команды. Обычно они классифицируются как "Фильтры" в Nushell.

Например, мы можем использовать [`where`](/commands/docs/where.md), чтобы отфильтровать содержимое таблицы так, чтобы она показывала только файлы размером более 10 килобайт:

```nu
ls | where size > 10kb
# => ╭───┬─────────────────┬──────┬───────────┬───────────────╮
# => │ # │      name       │ type │   size    │   modified    │
# => ├───┼─────────────────┼──────┼───────────┼───────────────┤
# => │ 0 │ CONTRIBUTING.md │ file │  11.0 KiB │ 5 months ago  │
# => │ 1 │ Cargo.lock      │ file │ 194.6 KiB │ 2 minutes ago │
# => │ 2 │ README.md       │ file │  12.0 KiB │ 16 hours ago  │
# => │ 3 │ toolkit.nu      │ file │  20.0 KiB │ 16 hours ago  │
# => ╰───┴─────────────────┴──────┴───────────┴───────────────╯
```

## Больше, чем просто каталоги

Конечно, это не ограничивается командой `ls`. Nushell следует философии Unix, где каждая команда делает одно дело хорошо, и вы можете ожидать, что вывод одной команды станет вводом другой. Это позволяет нам комбинировать команды в различных комбинациях.

Давайте рассмотрим другую команду:

```nu:no-line-numbers
ps
# => ╭───┬──────┬──────┬───────────────┬──────────┬──────┬───────────┬─────────╮
# => │ # │ pid  │ ppid │     name      │  status  │ cpu  │    mem    │ virtual │
# => ├───┼──────┼──────┼───────────────┼──────────┼──────┼───────────┼─────────┤
# => │ 0 │    1 │    0 │ init(void)    │ Sleeping │ 0.00 │   1.2 MiB │ 2.2 MiB │
# => │ 1 │    8 │    1 │ init          │ Sleeping │ 0.00 │ 124.0 KiB │ 2.3 MiB │
# => │ 2 │ 6565 │    1 │ SessionLeader │ Sleeping │ 0.00 │ 108.0 KiB │ 2.2 MiB │
# => │ 3 │ 6566 │ 6565 │ Relay(6567)   │ Sleeping │ 0.00 │ 116.0 KiB │ 2.2 MiB │
# => │ 4 │ 6567 │ 6566 │ nu            │ Running  │ 0.00 │  28.4 MiB │ 1.1 GiB │
# => ╰───┴──────┴──────┴───────────────┴──────────┴──────┴───────────┴─────────╯
```

Вы, возможно, знакомы с командой Linux/Unix `ps`. Она предоставляет список всех текущих процессов, запущенных в системе, вместе с их текущим статусом. Как и `ls`, Nushell предоставляет кросс-платформенную встроенную команду [`ps`](/commands/docs/ps.md), которая возвращает свои результаты в виде структурированных данных.

::: note
Традиционная Unix-команда `ps` по умолчанию показывает только текущий процесс и его родителей. Реализация Nushell по умолчанию показывает все процессы в системе.

Обычно выполнение `ps` в Nushell использует его **_внутреннюю_**, кросс-платформенную команду. Однако все еще возможно запустить **_внешнюю_**, зависящую от системы версию на платформах Unix/Linux, добавив перед ней символ каретки. Например:

```nu
^ps aux  # выполнить команду Unix ps со всеми процессами в пользовательском формате
```

См. [Запуск внешних системных команд](./running_externals.md) для получения дополнительных сведений.
:::

Что если мы хотим показать только процессы, которые активно работают? Как и с `ls` выше, мы также можем работать с таблицей, которую _выводит_ `ps`:

```nu
ps | where status == Running
# => ╭───┬──────┬──────┬──────┬─────────┬──────┬──────────┬─────────╮
# => │ # │ pid  │ ppid │ name │ status  │ cpu  │   mem    │ virtual │
# => ├───┼──────┼──────┼──────┼─────────┼──────┼──────────┼─────────┤
# => │ 0 │ 6585 │ 6584 │ nu   │ Running │ 0.00 │ 31.9 MiB │ 1.2 GiB │
# => ╰───┴──────┴──────┴──────┴─────────┴──────┴──────────┴─────────╯
```

::: tip
Помните выше, где столбец `size` из команды `ls` был `filesize`? Здесь `status` на самом деле просто строка, и вы можете использовать все обычные строковые операции и команды с ним, включая (как выше) сравнение `==`.

Вы можете изучить типы столбцов таблицы, используя:

```nu
ps | describe
# => table<pid: int, ppid: int, name: string, status: string, cpu: float, mem: filesize, virtual: filesize> (stream)
```

Команда [`describe`](/commands/docs/describe.md) может использоваться для отображения типа вывода любой команды или выражения.

:::

## Аргументы команд в конвейере

Иногда команда принимает _аргумент_ вместо _ввода_ конвейера. Для этого сценария Nushell предоставляет переменную [`$in`](./pipelines.md#pipeline-input-and-the-special-in-variable), которая позволяет использовать вывод предыдущей команды в виде переменной. Например:

```nu:line-numbers
ls
| sort-by size
| reverse
| first
| get name
| cp $in ~
```

::: tip Примечание по дизайну Nushell
По возможности, команды Nushell разработаны для работы с _вводом_ конвейера. Однако некоторые команды, такие как `cp` в этом примере, имеют два (или более) аргумента с разными значениями. В этом случае `cp` нужно знать как путь для _копирования_, так и _целевой_ путь. В результате эта команда более эргономична с двумя _позиционными параметрами_.
:::

::: tip
Команды Nushell могут быть разделены на несколько строк для удобочитаемости. Приведенный выше пример эквивалентен:

```nu
ls | sort-by size | reverse | first | get name | cp $in ~
```

См. также: [Многострочное редактирование](./line_editor.md#multi-line-editing)
:::

Первые три строки такие же, как в примере выше, поэтому давайте рассмотрим последние три:

4. Команда [`first`](/commands/docs/first.md) просто возвращает первое значение из таблицы. В данном случае это означает файл с наибольшим размером. Это файл `Cargo.lock`, если использовать список каталогов из второго примера выше. Этот "файл" является [`record`](./types_of_data.md#records) из таблицы, который все еще содержит свои столбцы/поля `name`, `type`, `size` и `modified`.
5. `get name` возвращает _значение_ поля `name` из предыдущей команды, то есть `"Cargo.lock"` (строка). Это также простой пример [`cell-path`](./types_of_data.md#cell-paths), который можно использовать для навигации и изоляции структурированных данных.
6. Последняя строка использует переменную `$in` для ссылки на вывод строки 5. Результат — команда, которая говорит _"Скопировать 'Cargo.lock' в домашний каталог"_

::: tip
[`get`](/commands/docs/get.md) и его аналог [`select`](/commands/docs/select.md) являются двумя из наиболее часто используемых фильтров в Nushell, но может быть не сразу понятно, в чем между ними разница. Когда вы будете готовы начать использовать их более активно, см. [Использование `get` и `select`](./navigating_structured_data.md#using-get-and-select) для руководства.
:::

## Получение помощи

Nushell предоставляет обширную систему помощи в оболочке. Например

```nu
# help <command>
help ls
# Или
ls --help
# Также
help operators
help escapes
```

::: tip Круто!
Нажмите клавишу <kbd>F1</kbd>, чтобы получить доступ к [меню](./line_editor.md#menus) помощи. Найдите команду `ps` здесь, но _не нажимайте <kbd>Enter</kbd> сразу_!

Вместо этого нажмите клавишу <kbd>Down Arrow</kbd> и обратите внимание, что вы прокручиваете раздел Примеры. Выделите пример, _затем_ нажмите <kbd>Enter</kbd>, и пример будет введен в командную строку, готовый к выполнению!

Это может быть отличным способом изучить и узнать об обширном наборе команд Nushell.
:::

Система помощи также имеет функцию "поиска":

```nu
help --find filesize
# или
help -f filesize
```

Возможно, вас уже не удивит, что система помощи сама по себе основана на структурированных данных! Обратите внимание, что вывод `help -f filesize` представляет собой таблицу.

Помощь для каждой команды хранится в виде записи с:

- Названием
- Категорией
- Типом (встроенная, плагин, пользовательская)
- Параметрами, которые она принимает
- Подписями, показывающими, какие типы данных она может принимать, а также выводить
- И многим другим

Вы можете просмотреть _все_ команды (кроме внешних) в виде одной большой таблицы, используя:

```nu
help commands
```

::: tip
Обратите внимание, что столбцы `params` и `input_output` в приведенном выше выводе являются _вложенными_ таблицами. Nushell позволяет [произвольно вложенные структуры данных](./navigating_structured_data.md#background).
:::

## `explore`'ing отсюда

Этот вывод `help commands` довольно длинный. Вы могли бы отправить его в пейджер, такой как `less` или `bat`, но Nushell включает встроенную команду `explore`, которая позволяет не только прокручивать, но и телескопировать вложенные данные. Попробуйте:

```nu
help commands | explore
```

Затем нажмите клавишу <kbd>Enter</kbd>, чтобы получить доступ к самим данным. Используйте клавиши со стрелками для прокрутки до команды `cp` и к столбцу `params`. Нажмите <kbd>Enter</kbd> еще раз, чтобы телескопировать полный список параметров, доступных для команды `cp`.

::: note
Нажатие клавиши <kbd>Esc</kbd> один раз возвращает из режима прокрутки в режим просмотра; Нажатие второй раз возвращает к предыдущему виду (или выходит, если уже на верхнем уровне просмотра).
:::

::: tip
Вы, конечно, можете использовать команду `explore` для _любых_ структурированных данных в Nushell. Это может включать данные JSON, поступающие из веб-API, электронную таблицу или файл CSV, YAML или что-либо, что может быть представлено как структурированные данные в Nushell.

Попробуйте `$env.config | explore` для развлечения!
:::
